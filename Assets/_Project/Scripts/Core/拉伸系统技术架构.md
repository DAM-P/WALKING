# Cube 拉伸系统 - 技术架构文档

## 📐 系统架构概览

```
┌─────────────────────────────────────────────────────────┐
│                   用户输入层 (MonoBehaviour)             │
│                   ExtendInputManager                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │ 方向检测  │→│ 预览控制  │→│ 执行请求  │              │
│  └──────────┘  └──────────┘  └──────────┘              │
└─────────────────────┬───────────────────────────────────┘
                      │ 添加/更新组件
┌─────────────────────▼───────────────────────────────────┐
│                   DOTS 数据层 (IComponentData)          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ ExtendPreview│  │ExtendExecution│  │ NeedsCollider│  │
│  │              │  │    Request    │  │              │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────┬───────────────────────────────────┘
                      │ 读取/处理
┌─────────────────────▼───────────────────────────────────┐
│                   DOTS 系统层 (ISystem)                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ExtendPreview │→│ExtendExecution│→│DynamicCollider│  │
│  │   System     │  │    System     │  │    System     │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────┬───────────────────────────────────┘
                      │ 实例化/修改
┌─────────────────────▼───────────────────────────────────┐
│                   Cube Entity 层                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  CubeTypeTag │  │ExtendChainData│  │CubeGridPos   │  │
│  │ (Extended)   │  │ (链追踪)     │  │ (坐标)       │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────┬───────────────────────────────────┘
                      │ 注册/查询
┌─────────────────────▼───────────────────────────────────┐
│                空间管理层 (Singleton)                     │
│  ┌──────────────────────────────────────────────────┐  │
│  │         OccupiedCubeMap (空间哈希表)             │  │
│  │  NativeHashMap<int3, Entity>                     │  │
│  │  O(1) 碰撞检测                                   │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

---

## 🧩 组件详解

### 1. 数据组件（Data Components）

#### CubeTypeTag
```csharp
public struct CubeTypeTag : IComponentData
{
    public CubeType Type; // Static, Dynamic, Extended
}
```
**用途**: 区分 Cube 类型，方便分类处理和清理

**生命周期**: 
- Static: 从 CubeLayout 生成时添加
- Extended: 拉伸时添加
- 存在于 Entity 整个生命周期

---

#### ExtendChainData
```csharp
public struct ExtendChainData : IComponentData
{
    public Entity RootEntity;   // 链的起点
    public int3 Direction;      // 拉伸方向
    public int IndexInChain;    // 在链中的位置
    public int ChainID;         // 链的唯一标识
}
```
**用途**: 追踪拉伸链的结构，支持批量删除

**关键字段**:
- `ChainID`: 时间戳生成，确保唯一性
- `IndexInChain`: 0 = 起点，1+ = 拉伸的 Cube

**使用场景**:
- 收回整条链（通过 ChainID 查询）
- 显示链的连接关系
- 计算链的稳定性

---

#### ExtendableTag
```csharp
public struct ExtendableTag : IComponentData
{
    public int MaxExtendLength;       // 最大拉伸长度
    public int CurrentExtensions;     // 已拉伸链数量
    public bool AllowMultipleChains;  // 允许多条链
}
```
**用途**: 标记可拉伸的 Cube，控制拉伸限制

**添加时机**: `CubeLayoutSpawnSystem` 生成可交互 Cube 时

**限制逻辑**:
```csharp
if (extendable.CurrentExtensions >= maxChains && !extendable.AllowMultipleChains)
{
    // 拒绝拉伸
}
```

---

#### ExtendPreview
```csharp
public struct ExtendPreview : IComponentData
{
    public int PreviewLength;      // 预览长度
    public int3 PreviewDirection;  // 预览方向
    public bool IsValid;           // 是否有效
    public int ValidLength;        // 实际可拉伸长度
}
```
**用途**: 存储预览状态，驱动预览渲染

**生命周期**: 
- 添加: 按下方向键
- 更新: 持续按住方向键
- 移除: 松开方向键或取消选择

**ValidLength 计算**:
```csharp
for (int i = 1; i <= PreviewLength; i++)
{
    int3 pos = startPos + Direction * i;
    if (OccupiedCubeMap.ContainsKey(pos))
        break; // 碰撞
    ValidLength = i;
}
```

---

#### CubeGridPosition
```csharp
public struct CubeGridPosition : IComponentData
{
    public int3 GridPosition;  // 整数网格坐标
    public bool IsRegistered;  // 是否已注册到哈希表
}
```
**用途**: 
1. 存储 Cube 的网格坐标（用于哈希）
2. 标记是否已注册到空间哈希表

**坐标计算**:
```csharp
GridPosition = new int3(math.round(transform.Position));
```

---

#### OccupiedCubeMap (Singleton)
```csharp
public struct OccupiedCubeMap : IComponentData
{
    public NativeHashMap<int3, Entity> Map;
    public bool IsInitialized;
}
```
**用途**: 空间哈希表，O(1) 碰撞检测

**容量**: 初始 1000，动态扩展

**操作**:
- `Add`: Cube 生成时
- `Remove`: Cube 销毁时
- `ContainsKey`: 碰撞检测

---

### 2. 临时组件（Temporary Components）

#### ExtendExecutionRequest
```csharp
public struct ExtendExecutionRequest : IComponentData
{
    public int3 Direction;
    public int Length;
    public int ChainID;
}
```
**用途**: 单帧标记，通知执行系统生成 Cube 链

**生命周期**: 1 帧（添加 → 执行 → 移除）

---

#### NeedsCollider (IEnableableComponent)
```csharp
public struct NeedsCollider : IComponentData, IEnableableComponent
{
    public float Size;
}
```
**用途**: 标记需要添加 GameObject BoxCollider

**IEnableableComponent**:
- 启用: 需要处理
- 禁用: 已处理（避免重复）

---

#### ColliderReference
```csharp
public struct ColliderReference : IComponentData
{
    public int GameObjectInstanceID;
}
```
**用途**: 存储 GameObject Collider 的 InstanceID，用于同步位置

---

## ⚙️ 系统详解

### 1. OccupiedCubeMapSystem

**职责**: 维护空间哈希表

**更新组**: `InitializationSystemGroup`（最早执行）

**流程**:
```
OnCreate → 创建 NativeHashMap (容量 1000)
   ↓
OnUpdate → RegisterCubeJob (并行注册新 Cube)
   ↓
OnUpdate → CleanupDestroyedCubes (清理已销毁 Entity)
   ↓
OnDestroy → Dispose NativeHashMap
```

**性能**:
- 注册: O(1) × N (N = 新 Cube 数量)
- 清理: O(M) (M = 已销毁 Entity 数量)

---

### 2. ExtendInputManager (MonoBehaviour)

**职责**: 处理键盘输入，管理预览

**更新**: Unity `Update()` (每帧)

**状态机**:
```
Idle (无选中)
  ↓ 选中 Cube
Selected (已选中)
  ↓ 按下方向键
Holding (按住中)
  ↓ holdTime >= threshold
Previewing (预览中)
  ↓ 持续按住 → 延长预览
  ↓ 松开方向键
Executing (确认拉伸)
  ↓ 添加 ExtendExecutionRequest
Selected (回到已选中)
```

**关键参数**:
- `holdThreshold`: 0.1s（防误触）
- `extendInterval`: 0.2s（延长速度）

---

### 3. ExtendPreviewSystem

**职责**: 碰撞检测 + 预览渲染

**更新组**: `LateSimulationSystemGroup`

**流程**:
```
查询有 ExtendPreview 的 Entity
  ↓
计算 ValidLength (碰撞检测)
  ↓
更新 ExtendPreview.ValidLength
  ↓
绘制预览 (Debug.DrawLine)
  ├─ 绿色线框: 可拉伸
  └─ 红色线框: 碰撞
```

**碰撞检测算法**:
```csharp
for (int i = 1; i <= requestedLength; i++)
{
    int3 testPos = startPos + direction * i;
    if (OccupiedCubeMap.ContainsKey(testPos))
        break; // 碰撞
    validLength = i;
}
```

**性能**: O(L) × N (L = 预览长度, N = 预览 Cube 数量)

---

### 4. ExtendExecutionSystem

**职责**: 生成 Cube 链

**更新组**: `SimulationSystemGroup`

**更新顺序**: `[UpdateAfter(typeof(ExtendPreviewSystem))]`

**流程**:
```
查询有 ExtendExecutionRequest 的 Entity
  ↓
获取 ExtendSettings (Prefab, Size, Color)
  ↓
for (int i = 1; i <= request.Length; i++)
  ├─ 检查碰撞 (再次验证)
  ├─ 实例化 Cube Entity
  ├─ 设置位置 (GridPosition → WorldPosition)
  ├─ 添加组件:
  │   ├─ CubeGridPosition
  │   ├─ CubeTypeTag (Extended)
  │   ├─ ExtendChainData
  │   ├─ StageCubeTag
  │   ├─ NeedsCollider (如果启用)
  │   └─ URPMaterialPropertyBaseColor (如果启用)
  └─ 更新 OccupiedCubeMap (下一帧自动)
  ↓
移除 ExtendExecutionRequest 和 ExtendPreview
```

**错误处理**:
- 碰撞: 停止生成，记录成功数量
- Prefab 未设置: 提前返回，记录错误

---

### 5. DynamicColliderSystem

**职责**: 为拉伸的 Cube 创建 GameObject BoxCollider

**更新组**: `LateSimulationSystemGroup`

**流程**:
```
查询有 NeedsCollider 且无 ColliderReference 的 Entity
  ↓
创建 GameObject (DynamicColliders 子对象)
  ├─ 命名: Collider_Entity_{Index}_{Version}
  ├─ 位置: 同步 Entity 的 LocalTransform
  └─ 组件: BoxCollider (size = NeedsCollider.Size)
  ↓
添加 ColliderReference (存储 InstanceID)
  ↓
禁用 NeedsCollider (标记已处理)
  ↓
持续同步 Collider 位置 (如果 Transform 变化)
```

**GameObject 层级**:
```
Hierarchy
└─ DynamicColliders
   ├─ Collider_Entity_123_1
   │  └─ BoxCollider (size 1, center 0)
   ├─ Collider_Entity_124_1
   └─ Collider_Entity_125_1
```

**性能优化**:
- 仅在 Entity 位置变化时同步
- 使用 InstanceID 查找（避免存储 GameObject 引用）

---

## 🔄 数据流详解

### 完整拉伸流程

```
[1] 用户输入
    ↓
    ExtendInputManager.Update()
    ├─ GetDirectionInput() → int3(0, 0, 1)
    └─ HandleDirectionHold()
        ├─ holdTime += deltaTime
        └─ if (holdTime >= threshold)
            └─ EntityManager.AddComponentData<ExtendPreview>()
    ↓
[2] 预览计算
    ↓
    ExtendPreviewSystem.OnUpdate()
    ├─ SystemAPI.GetSingleton<OccupiedCubeMap>()
    └─ Entities.ForEach (有 ExtendPreview 的)
        ├─ CalculateValidLength()
        │   └─ for (i = 1 to PreviewLength)
        │       └─ if (map.ContainsKey(pos)) break
        ├─ preview.ValidLength = validLength
        └─ DrawPreview() (Debug.DrawLine)
    ↓
[3] 用户确认
    ↓
    ExtendInputManager.Update()
    └─ HandleDirectionRelease()
        └─ ConfirmExtend()
            └─ EntityManager.AddComponentData<ExtendExecutionRequest>()
    ↓
[4] 执行生成
    ↓
    ExtendExecutionSystem.OnUpdate()
    └─ Entities.ForEach (有 ExtendExecutionRequest 的)
        ├─ for (i = 1 to request.Length)
        │   ├─ newCube = ecb.Instantiate(prefab)
        │   ├─ ecb.SetComponent<LocalTransform>()
        │   ├─ ecb.AddComponent<CubeGridPosition>()
        │   ├─ ecb.AddComponent<CubeTypeTag>()
        │   ├─ ecb.AddComponent<ExtendChainData>()
        │   ├─ ecb.AddComponent<NeedsCollider>()
        │   └─ ecb.AddComponent<URPMaterialPropertyBaseColor>()
        ├─ ecb.RemoveComponent<ExtendExecutionRequest>()
        └─ ecb.RemoveComponent<ExtendPreview>()
    ↓
[5] Collider 生成 (下一帧)
    ↓
    OccupiedCubeMapSystem.OnUpdate()
    └─ RegisterCubeJob.Execute()
        └─ map.TryAdd(GridPosition, entity)
    ↓
    DynamicColliderSystem.OnUpdate()
    └─ Entities.ForEach (有 NeedsCollider 的)
        ├─ colliderGO = new GameObject()
        ├─ colliderGO.AddComponent<BoxCollider>()
        ├─ ecb.AddComponent<ColliderReference>()
        └─ ecb.SetComponentEnabled<NeedsCollider>(false)
    ↓
[6] 完成
    ✅ Cube 链生成
    ✅ Collider 添加
    ✅ 玩家可以站立
```

---

## 🧪 测试用例

### 单元测试（概念）

#### Test 1: 空间哈希表注册
```csharp
[Test]
public void OccupiedCubeMap_RegisterCube_Success()
{
    // Arrange
    var map = new NativeHashMap<int3, Entity>(100, Allocator.Temp);
    var pos = new int3(0, 0, 0);
    var entity = world.EntityManager.CreateEntity();
    
    // Act
    map.TryAdd(pos, entity);
    
    // Assert
    Assert.IsTrue(map.ContainsKey(pos));
    Assert.AreEqual(entity, map[pos]);
}
```

#### Test 2: 碰撞检测
```csharp
[Test]
public void ExtendPreview_CollisionDetection_StopsAtOccupiedPosition()
{
    // Arrange
    var map = CreateMapWithCubeAt(new int3(3, 0, 0));
    var startPos = new int3(0, 0, 0);
    var direction = new int3(1, 0, 0);
    var requestedLength = 5;
    
    // Act
    int validLength = CalculateValidLength(startPos, direction, requestedLength, map);
    
    // Assert
    Assert.AreEqual(2, validLength); // 停在 (2,0,0)，因为 (3,0,0) 被占用
}
```

#### Test 3: 拉伸生成
```csharp
[Test]
public void ExtendExecution_GeneratesCubesWithCorrectComponents()
{
    // Arrange
    var rootEntity = CreateCubeWithExtendableTag();
    AddComponent(rootEntity, new ExtendExecutionRequest
    {
        Direction = new int3(0, 1, 0),
        Length = 3,
        ChainID = 12345
    });
    
    // Act
    ExtendExecutionSystem.Update();
    
    // Assert
    var query = EntityManager.CreateEntityQuery(typeof(ExtendChainData));
    Assert.AreEqual(3, query.CalculateEntityCount());
    
    foreach (var entity in query.ToEntityArray(Allocator.Temp))
    {
        var chain = EntityManager.GetComponentData<ExtendChainData>(entity);
        Assert.AreEqual(rootEntity, chain.RootEntity);
        Assert.AreEqual(12345, chain.ChainID);
    }
}
```

---

## 📊 性能分析

### 时间复杂度

| 操作 | 复杂度 | 说明 |
|------|--------|------|
| 碰撞检测 | O(L) | L = 预览长度 |
| Cube 生成 | O(N) | N = 拉伸长度 |
| 空间哈希注册 | O(1) | 单个 Cube |
| 空间哈希查询 | O(1) | 单个坐标 |
| Collider 同步 | O(C) | C = Collider 数量 |

### 内存占用

| 组件 | 大小 | 数量 (假设) | 总计 |
|------|------|------------|------|
| CubeTypeTag | 1 byte | 1000 | 1 KB |
| ExtendChainData | 24 bytes | 100 | 2.4 KB |
| CubeGridPosition | 16 bytes | 1000 | 16 KB |
| OccupiedCubeMap | ~24 KB | 1 | 24 KB |
| **总计** | - | - | **~43 KB** |

### 性能建议

1. **拉伸长度**: 5-10 格（推荐）
2. **同时拉伸链数**: < 5 条
3. **总 Cube 数**: < 10,000
4. **空间哈希容量**: 动态扩展（初始 1000）

---

## 🔧 扩展点

### 1. 自定义预览渲染

替换 `Debug.DrawLine` 为 Entity 预览：

```csharp
// ExtendPreviewSystem.cs
private void CreatePreviewEntities()
{
    for (int i = 1; i <= previewLength; i++)
    {
        var previewEntity = ecb.Instantiate(previewPrefab);
        ecb.AddComponent(previewEntity, new PreviewTag());
        ecb.AddComponent(previewEntity, new URPMaterialPropertyBaseColor
        {
            Value = isValid ? greenTransparent : redTransparent
        });
    }
}
```

### 2. 拉伸动画

在 `ExtendExecutionSystem` 中添加 Scale 动画：

```csharp
ecb.AddComponent(newCube, new ScaleAnimation
{
    StartScale = 0f,
    EndScale = 1f,
    Duration = 0.2f,
    ElapsedTime = 0f
});
```

然后创建 `ScaleAnimationSystem`:
```csharp
public partial struct ScaleAnimationSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        foreach (var (anim, transform) in SystemAPI.Query<RefRW<ScaleAnimation>, RefRW<LocalTransform>>())
        {
            anim.ValueRW.ElapsedTime += SystemAPI.Time.DeltaTime;
            float t = math.saturate(anim.ValueRO.ElapsedTime / anim.ValueRO.Duration);
            transform.ValueRW.Scale = math.lerp(anim.ValueRO.StartScale, anim.ValueRO.EndScale, t);
        }
    }
}
```

### 3. 收回功能

创建 `ExtendRetractSystem`:

```csharp
public partial struct ExtendRetractSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        // 监听 R 键
        if (!Input.GetKeyDown(KeyCode.R)) return;
        
        var ecb = new EntityCommandBuffer(Allocator.Temp);
        
        // 查找最近的链（最大 ChainID）
        int latestChainID = 0;
        Entities.ForEach((in ExtendChainData chain) =>
        {
            if (chain.ChainID > latestChainID)
                latestChainID = chain.ChainID;
        }).Run();
        
        // 删除该链的所有 Cube
        Entities.ForEach((Entity entity, in ExtendChainData chain) =>
        {
            if (chain.ChainID == latestChainID)
            {
                ecb.DestroyEntity(entity);
            }
        }).Run();
        
        ecb.Playback(state.EntityManager);
    }
}
```

---

## 🐛 调试技巧

### 1. Entity Debugger

Window → Entities → Hierarchy

查看：
- ExtendPreview 组件值
- ExtendChainData 链结构
- CubeGridPosition 坐标

### 2. 空间哈希可视化

在 `OccupiedCubeMapSystem` 中：
```csharp
void OnDrawGizmos()
{
    if (!SystemAPI.TryGetSingleton<OccupiedCubeMap>(out var map))
        return;
    
    foreach (var (pos, entity) in map.Map)
    {
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireCube((Vector3)(float3)pos, Vector3.one * 0.9f);
    }
}
```

### 3. Console 日志级别

ExtendInputManager:
- `<cyan>`: 预览开始
- `<green>`: 确认拉伸

ExtendExecutionSystem:
- `<green>`: 成功
- `<yellow>`: 警告（碰撞）
- `<red>`: 错误

---

## 📚 参考资料

### Unity DOTS
- [Entities 1.0 Documentation](https://docs.unity3d.com/Packages/com.unity.entities@latest)
- [ECS Best Practices](https://docs.unity3d.com/Packages/com.unity.entities@latest/index.html?subfolder=/manual/ecs_best_practices.html)

### 相关系统
- [选择系统](./Cube选择系统使用指南.md)
- [关卡管理](./关卡管理系统使用指南.md)
- [Grid Brush](../Editor/GridBrush/README.md)

---

## 📝 版本历史

### v1.0.0 (MVP) - 2025-10-24
- ✅ 基础拉伸功能
- ✅ 空间哈希表碰撞检测
- ✅ 键盘输入控制
- ✅ Debug.DrawLine 预览
- ✅ 动态 GameObject Collider

### 未来计划
- v1.1.0: 拉伸动画
- v1.2.0: 收回功能
- v1.3.0: 鼠标拖拽
- v2.0.0: 稳定性系统

---

**文档维护**: AI Assistant & Development Team
**最后更新**: 2025-10-24

