# Cube æ‹‰ä¼¸ç³»ç»Ÿ - æŠ€æœ¯æ¶æ„æ–‡æ¡£

## ğŸ“ ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ç”¨æˆ·è¾“å…¥å±‚ (MonoBehaviour)             â”‚
â”‚                   ExtendInputManager                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚ æ–¹å‘æ£€æµ‹  â”‚â†’â”‚ é¢„è§ˆæ§åˆ¶  â”‚â†’â”‚ æ‰§è¡Œè¯·æ±‚  â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ æ·»åŠ /æ›´æ–°ç»„ä»¶
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   DOTS æ•°æ®å±‚ (IComponentData)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ ExtendPreviewâ”‚  â”‚ExtendExecutionâ”‚  â”‚ NeedsColliderâ”‚  â”‚
â”‚  â”‚              â”‚  â”‚    Request    â”‚  â”‚              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ è¯»å–/å¤„ç†
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   DOTS ç³»ç»Ÿå±‚ (ISystem)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ExtendPreview â”‚â†’â”‚ExtendExecutionâ”‚â†’â”‚DynamicColliderâ”‚  â”‚
â”‚  â”‚   System     â”‚  â”‚    System     â”‚  â”‚    System     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ å®ä¾‹åŒ–/ä¿®æ”¹
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Cube Entity å±‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  CubeTypeTag â”‚  â”‚ExtendChainDataâ”‚  â”‚CubeGridPos   â”‚  â”‚
â”‚  â”‚ (Extended)   â”‚  â”‚ (é“¾è¿½è¸ª)     â”‚  â”‚ (åæ ‡)       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ æ³¨å†Œ/æŸ¥è¯¢
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                ç©ºé—´ç®¡ç†å±‚ (Singleton)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         OccupiedCubeMap (ç©ºé—´å“ˆå¸Œè¡¨)             â”‚  â”‚
â”‚  â”‚  NativeHashMap<int3, Entity>                     â”‚  â”‚
â”‚  â”‚  O(1) ç¢°æ’æ£€æµ‹                                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§© ç»„ä»¶è¯¦è§£

### 1. æ•°æ®ç»„ä»¶ï¼ˆData Componentsï¼‰

#### CubeTypeTag
```csharp
public struct CubeTypeTag : IComponentData
{
    public CubeType Type; // Static, Dynamic, Extended
}
```
**ç”¨é€”**: åŒºåˆ† Cube ç±»å‹ï¼Œæ–¹ä¾¿åˆ†ç±»å¤„ç†å’Œæ¸…ç†

**ç”Ÿå‘½å‘¨æœŸ**: 
- Static: ä» CubeLayout ç”Ÿæˆæ—¶æ·»åŠ 
- Extended: æ‹‰ä¼¸æ—¶æ·»åŠ 
- å­˜åœ¨äº Entity æ•´ä¸ªç”Ÿå‘½å‘¨æœŸ

---

#### ExtendChainData
```csharp
public struct ExtendChainData : IComponentData
{
    public Entity RootEntity;   // é“¾çš„èµ·ç‚¹
    public int3 Direction;      // æ‹‰ä¼¸æ–¹å‘
    public int IndexInChain;    // åœ¨é“¾ä¸­çš„ä½ç½®
    public int ChainID;         // é“¾çš„å”¯ä¸€æ ‡è¯†
}
```
**ç”¨é€”**: è¿½è¸ªæ‹‰ä¼¸é“¾çš„ç»“æ„ï¼Œæ”¯æŒæ‰¹é‡åˆ é™¤

**å…³é”®å­—æ®µ**:
- `ChainID`: æ—¶é—´æˆ³ç”Ÿæˆï¼Œç¡®ä¿å”¯ä¸€æ€§
- `IndexInChain`: 0 = èµ·ç‚¹ï¼Œ1+ = æ‹‰ä¼¸çš„ Cube

**ä½¿ç”¨åœºæ™¯**:
- æ”¶å›æ•´æ¡é“¾ï¼ˆé€šè¿‡ ChainID æŸ¥è¯¢ï¼‰
- æ˜¾ç¤ºé“¾çš„è¿æ¥å…³ç³»
- è®¡ç®—é“¾çš„ç¨³å®šæ€§

---

#### ExtendableTag
```csharp
public struct ExtendableTag : IComponentData
{
    public int MaxExtendLength;       // æœ€å¤§æ‹‰ä¼¸é•¿åº¦
    public int CurrentExtensions;     // å·²æ‹‰ä¼¸é“¾æ•°é‡
    public bool AllowMultipleChains;  // å…è®¸å¤šæ¡é“¾
}
```
**ç”¨é€”**: æ ‡è®°å¯æ‹‰ä¼¸çš„ Cubeï¼Œæ§åˆ¶æ‹‰ä¼¸é™åˆ¶

**æ·»åŠ æ—¶æœº**: `CubeLayoutSpawnSystem` ç”Ÿæˆå¯äº¤äº’ Cube æ—¶

**é™åˆ¶é€»è¾‘**:
```csharp
if (extendable.CurrentExtensions >= maxChains && !extendable.AllowMultipleChains)
{
    // æ‹’ç»æ‹‰ä¼¸
}
```

---

#### ExtendPreview
```csharp
public struct ExtendPreview : IComponentData
{
    public int PreviewLength;      // é¢„è§ˆé•¿åº¦
    public int3 PreviewDirection;  // é¢„è§ˆæ–¹å‘
    public bool IsValid;           // æ˜¯å¦æœ‰æ•ˆ
    public int ValidLength;        // å®é™…å¯æ‹‰ä¼¸é•¿åº¦
}
```
**ç”¨é€”**: å­˜å‚¨é¢„è§ˆçŠ¶æ€ï¼Œé©±åŠ¨é¢„è§ˆæ¸²æŸ“

**ç”Ÿå‘½å‘¨æœŸ**: 
- æ·»åŠ : æŒ‰ä¸‹æ–¹å‘é”®
- æ›´æ–°: æŒç»­æŒ‰ä½æ–¹å‘é”®
- ç§»é™¤: æ¾å¼€æ–¹å‘é”®æˆ–å–æ¶ˆé€‰æ‹©

**ValidLength è®¡ç®—**:
```csharp
for (int i = 1; i <= PreviewLength; i++)
{
    int3 pos = startPos + Direction * i;
    if (OccupiedCubeMap.ContainsKey(pos))
        break; // ç¢°æ’
    ValidLength = i;
}
```

---

#### CubeGridPosition
```csharp
public struct CubeGridPosition : IComponentData
{
    public int3 GridPosition;  // æ•´æ•°ç½‘æ ¼åæ ‡
    public bool IsRegistered;  // æ˜¯å¦å·²æ³¨å†Œåˆ°å“ˆå¸Œè¡¨
}
```
**ç”¨é€”**: 
1. å­˜å‚¨ Cube çš„ç½‘æ ¼åæ ‡ï¼ˆç”¨äºå“ˆå¸Œï¼‰
2. æ ‡è®°æ˜¯å¦å·²æ³¨å†Œåˆ°ç©ºé—´å“ˆå¸Œè¡¨

**åæ ‡è®¡ç®—**:
```csharp
GridPosition = new int3(math.round(transform.Position));
```

---

#### OccupiedCubeMap (Singleton)
```csharp
public struct OccupiedCubeMap : IComponentData
{
    public NativeHashMap<int3, Entity> Map;
    public bool IsInitialized;
}
```
**ç”¨é€”**: ç©ºé—´å“ˆå¸Œè¡¨ï¼ŒO(1) ç¢°æ’æ£€æµ‹

**å®¹é‡**: åˆå§‹ 1000ï¼ŒåŠ¨æ€æ‰©å±•

**æ“ä½œ**:
- `Add`: Cube ç”Ÿæˆæ—¶
- `Remove`: Cube é”€æ¯æ—¶
- `ContainsKey`: ç¢°æ’æ£€æµ‹

---

### 2. ä¸´æ—¶ç»„ä»¶ï¼ˆTemporary Componentsï¼‰

#### ExtendExecutionRequest
```csharp
public struct ExtendExecutionRequest : IComponentData
{
    public int3 Direction;
    public int Length;
    public int ChainID;
}
```
**ç”¨é€”**: å•å¸§æ ‡è®°ï¼Œé€šçŸ¥æ‰§è¡Œç³»ç»Ÿç”Ÿæˆ Cube é“¾

**ç”Ÿå‘½å‘¨æœŸ**: 1 å¸§ï¼ˆæ·»åŠ  â†’ æ‰§è¡Œ â†’ ç§»é™¤ï¼‰

---

#### NeedsCollider (IEnableableComponent)
```csharp
public struct NeedsCollider : IComponentData, IEnableableComponent
{
    public float Size;
}
```
**ç”¨é€”**: æ ‡è®°éœ€è¦æ·»åŠ  GameObject BoxCollider

**IEnableableComponent**:
- å¯ç”¨: éœ€è¦å¤„ç†
- ç¦ç”¨: å·²å¤„ç†ï¼ˆé¿å…é‡å¤ï¼‰

---

#### ColliderReference
```csharp
public struct ColliderReference : IComponentData
{
    public int GameObjectInstanceID;
}
```
**ç”¨é€”**: å­˜å‚¨ GameObject Collider çš„ InstanceIDï¼Œç”¨äºåŒæ­¥ä½ç½®

---

## âš™ï¸ ç³»ç»Ÿè¯¦è§£

### 1. OccupiedCubeMapSystem

**èŒè´£**: ç»´æŠ¤ç©ºé—´å“ˆå¸Œè¡¨

**æ›´æ–°ç»„**: `InitializationSystemGroup`ï¼ˆæœ€æ—©æ‰§è¡Œï¼‰

**æµç¨‹**:
```
OnCreate â†’ åˆ›å»º NativeHashMap (å®¹é‡ 1000)
   â†“
OnUpdate â†’ RegisterCubeJob (å¹¶è¡Œæ³¨å†Œæ–° Cube)
   â†“
OnUpdate â†’ CleanupDestroyedCubes (æ¸…ç†å·²é”€æ¯ Entity)
   â†“
OnDestroy â†’ Dispose NativeHashMap
```

**æ€§èƒ½**:
- æ³¨å†Œ: O(1) Ã— N (N = æ–° Cube æ•°é‡)
- æ¸…ç†: O(M) (M = å·²é”€æ¯ Entity æ•°é‡)

---

### 2. ExtendInputManager (MonoBehaviour)

**èŒè´£**: å¤„ç†é”®ç›˜è¾“å…¥ï¼Œç®¡ç†é¢„è§ˆ

**æ›´æ–°**: Unity `Update()` (æ¯å¸§)

**çŠ¶æ€æœº**:
```
Idle (æ— é€‰ä¸­)
  â†“ é€‰ä¸­ Cube
Selected (å·²é€‰ä¸­)
  â†“ æŒ‰ä¸‹æ–¹å‘é”®
Holding (æŒ‰ä½ä¸­)
  â†“ holdTime >= threshold
Previewing (é¢„è§ˆä¸­)
  â†“ æŒç»­æŒ‰ä½ â†’ å»¶é•¿é¢„è§ˆ
  â†“ æ¾å¼€æ–¹å‘é”®
Executing (ç¡®è®¤æ‹‰ä¼¸)
  â†“ æ·»åŠ  ExtendExecutionRequest
Selected (å›åˆ°å·²é€‰ä¸­)
```

**å…³é”®å‚æ•°**:
- `holdThreshold`: 0.1sï¼ˆé˜²è¯¯è§¦ï¼‰
- `extendInterval`: 0.2sï¼ˆå»¶é•¿é€Ÿåº¦ï¼‰

---

### 3. ExtendPreviewSystem

**èŒè´£**: ç¢°æ’æ£€æµ‹ + é¢„è§ˆæ¸²æŸ“

**æ›´æ–°ç»„**: `LateSimulationSystemGroup`

**æµç¨‹**:
```
æŸ¥è¯¢æœ‰ ExtendPreview çš„ Entity
  â†“
è®¡ç®— ValidLength (ç¢°æ’æ£€æµ‹)
  â†“
æ›´æ–° ExtendPreview.ValidLength
  â†“
ç»˜åˆ¶é¢„è§ˆ (Debug.DrawLine)
  â”œâ”€ ç»¿è‰²çº¿æ¡†: å¯æ‹‰ä¼¸
  â””â”€ çº¢è‰²çº¿æ¡†: ç¢°æ’
```

**ç¢°æ’æ£€æµ‹ç®—æ³•**:
```csharp
for (int i = 1; i <= requestedLength; i++)
{
    int3 testPos = startPos + direction * i;
    if (OccupiedCubeMap.ContainsKey(testPos))
        break; // ç¢°æ’
    validLength = i;
}
```

**æ€§èƒ½**: O(L) Ã— N (L = é¢„è§ˆé•¿åº¦, N = é¢„è§ˆ Cube æ•°é‡)

---

### 4. ExtendExecutionSystem

**èŒè´£**: ç”Ÿæˆ Cube é“¾

**æ›´æ–°ç»„**: `SimulationSystemGroup`

**æ›´æ–°é¡ºåº**: `[UpdateAfter(typeof(ExtendPreviewSystem))]`

**æµç¨‹**:
```
æŸ¥è¯¢æœ‰ ExtendExecutionRequest çš„ Entity
  â†“
è·å– ExtendSettings (Prefab, Size, Color)
  â†“
for (int i = 1; i <= request.Length; i++)
  â”œâ”€ æ£€æŸ¥ç¢°æ’ (å†æ¬¡éªŒè¯)
  â”œâ”€ å®ä¾‹åŒ– Cube Entity
  â”œâ”€ è®¾ç½®ä½ç½® (GridPosition â†’ WorldPosition)
  â”œâ”€ æ·»åŠ ç»„ä»¶:
  â”‚   â”œâ”€ CubeGridPosition
  â”‚   â”œâ”€ CubeTypeTag (Extended)
  â”‚   â”œâ”€ ExtendChainData
  â”‚   â”œâ”€ StageCubeTag
  â”‚   â”œâ”€ NeedsCollider (å¦‚æœå¯ç”¨)
  â”‚   â””â”€ URPMaterialPropertyBaseColor (å¦‚æœå¯ç”¨)
  â””â”€ æ›´æ–° OccupiedCubeMap (ä¸‹ä¸€å¸§è‡ªåŠ¨)
  â†“
ç§»é™¤ ExtendExecutionRequest å’Œ ExtendPreview
```

**é”™è¯¯å¤„ç†**:
- ç¢°æ’: åœæ­¢ç”Ÿæˆï¼Œè®°å½•æˆåŠŸæ•°é‡
- Prefab æœªè®¾ç½®: æå‰è¿”å›ï¼Œè®°å½•é”™è¯¯

---

### 5. DynamicColliderSystem

**èŒè´£**: ä¸ºæ‹‰ä¼¸çš„ Cube åˆ›å»º GameObject BoxCollider

**æ›´æ–°ç»„**: `LateSimulationSystemGroup`

**æµç¨‹**:
```
æŸ¥è¯¢æœ‰ NeedsCollider ä¸”æ—  ColliderReference çš„ Entity
  â†“
åˆ›å»º GameObject (DynamicColliders å­å¯¹è±¡)
  â”œâ”€ å‘½å: Collider_Entity_{Index}_{Version}
  â”œâ”€ ä½ç½®: åŒæ­¥ Entity çš„ LocalTransform
  â””â”€ ç»„ä»¶: BoxCollider (size = NeedsCollider.Size)
  â†“
æ·»åŠ  ColliderReference (å­˜å‚¨ InstanceID)
  â†“
ç¦ç”¨ NeedsCollider (æ ‡è®°å·²å¤„ç†)
  â†“
æŒç»­åŒæ­¥ Collider ä½ç½® (å¦‚æœ Transform å˜åŒ–)
```

**GameObject å±‚çº§**:
```
Hierarchy
â””â”€ DynamicColliders
   â”œâ”€ Collider_Entity_123_1
   â”‚  â””â”€ BoxCollider (size 1, center 0)
   â”œâ”€ Collider_Entity_124_1
   â””â”€ Collider_Entity_125_1
```

**æ€§èƒ½ä¼˜åŒ–**:
- ä»…åœ¨ Entity ä½ç½®å˜åŒ–æ—¶åŒæ­¥
- ä½¿ç”¨ InstanceID æŸ¥æ‰¾ï¼ˆé¿å…å­˜å‚¨ GameObject å¼•ç”¨ï¼‰

---

## ğŸ”„ æ•°æ®æµè¯¦è§£

### å®Œæ•´æ‹‰ä¼¸æµç¨‹

```
[1] ç”¨æˆ·è¾“å…¥
    â†“
    ExtendInputManager.Update()
    â”œâ”€ GetDirectionInput() â†’ int3(0, 0, 1)
    â””â”€ HandleDirectionHold()
        â”œâ”€ holdTime += deltaTime
        â””â”€ if (holdTime >= threshold)
            â””â”€ EntityManager.AddComponentData<ExtendPreview>()
    â†“
[2] é¢„è§ˆè®¡ç®—
    â†“
    ExtendPreviewSystem.OnUpdate()
    â”œâ”€ SystemAPI.GetSingleton<OccupiedCubeMap>()
    â””â”€ Entities.ForEach (æœ‰ ExtendPreview çš„)
        â”œâ”€ CalculateValidLength()
        â”‚   â””â”€ for (i = 1 to PreviewLength)
        â”‚       â””â”€ if (map.ContainsKey(pos)) break
        â”œâ”€ preview.ValidLength = validLength
        â””â”€ DrawPreview() (Debug.DrawLine)
    â†“
[3] ç”¨æˆ·ç¡®è®¤
    â†“
    ExtendInputManager.Update()
    â””â”€ HandleDirectionRelease()
        â””â”€ ConfirmExtend()
            â””â”€ EntityManager.AddComponentData<ExtendExecutionRequest>()
    â†“
[4] æ‰§è¡Œç”Ÿæˆ
    â†“
    ExtendExecutionSystem.OnUpdate()
    â””â”€ Entities.ForEach (æœ‰ ExtendExecutionRequest çš„)
        â”œâ”€ for (i = 1 to request.Length)
        â”‚   â”œâ”€ newCube = ecb.Instantiate(prefab)
        â”‚   â”œâ”€ ecb.SetComponent<LocalTransform>()
        â”‚   â”œâ”€ ecb.AddComponent<CubeGridPosition>()
        â”‚   â”œâ”€ ecb.AddComponent<CubeTypeTag>()
        â”‚   â”œâ”€ ecb.AddComponent<ExtendChainData>()
        â”‚   â”œâ”€ ecb.AddComponent<NeedsCollider>()
        â”‚   â””â”€ ecb.AddComponent<URPMaterialPropertyBaseColor>()
        â”œâ”€ ecb.RemoveComponent<ExtendExecutionRequest>()
        â””â”€ ecb.RemoveComponent<ExtendPreview>()
    â†“
[5] Collider ç”Ÿæˆ (ä¸‹ä¸€å¸§)
    â†“
    OccupiedCubeMapSystem.OnUpdate()
    â””â”€ RegisterCubeJob.Execute()
        â””â”€ map.TryAdd(GridPosition, entity)
    â†“
    DynamicColliderSystem.OnUpdate()
    â””â”€ Entities.ForEach (æœ‰ NeedsCollider çš„)
        â”œâ”€ colliderGO = new GameObject()
        â”œâ”€ colliderGO.AddComponent<BoxCollider>()
        â”œâ”€ ecb.AddComponent<ColliderReference>()
        â””â”€ ecb.SetComponentEnabled<NeedsCollider>(false)
    â†“
[6] å®Œæˆ
    âœ… Cube é“¾ç”Ÿæˆ
    âœ… Collider æ·»åŠ 
    âœ… ç©å®¶å¯ä»¥ç«™ç«‹
```

---

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

### å•å…ƒæµ‹è¯•ï¼ˆæ¦‚å¿µï¼‰

#### Test 1: ç©ºé—´å“ˆå¸Œè¡¨æ³¨å†Œ
```csharp
[Test]
public void OccupiedCubeMap_RegisterCube_Success()
{
    // Arrange
    var map = new NativeHashMap<int3, Entity>(100, Allocator.Temp);
    var pos = new int3(0, 0, 0);
    var entity = world.EntityManager.CreateEntity();
    
    // Act
    map.TryAdd(pos, entity);
    
    // Assert
    Assert.IsTrue(map.ContainsKey(pos));
    Assert.AreEqual(entity, map[pos]);
}
```

#### Test 2: ç¢°æ’æ£€æµ‹
```csharp
[Test]
public void ExtendPreview_CollisionDetection_StopsAtOccupiedPosition()
{
    // Arrange
    var map = CreateMapWithCubeAt(new int3(3, 0, 0));
    var startPos = new int3(0, 0, 0);
    var direction = new int3(1, 0, 0);
    var requestedLength = 5;
    
    // Act
    int validLength = CalculateValidLength(startPos, direction, requestedLength, map);
    
    // Assert
    Assert.AreEqual(2, validLength); // åœåœ¨ (2,0,0)ï¼Œå› ä¸º (3,0,0) è¢«å ç”¨
}
```

#### Test 3: æ‹‰ä¼¸ç”Ÿæˆ
```csharp
[Test]
public void ExtendExecution_GeneratesCubesWithCorrectComponents()
{
    // Arrange
    var rootEntity = CreateCubeWithExtendableTag();
    AddComponent(rootEntity, new ExtendExecutionRequest
    {
        Direction = new int3(0, 1, 0),
        Length = 3,
        ChainID = 12345
    });
    
    // Act
    ExtendExecutionSystem.Update();
    
    // Assert
    var query = EntityManager.CreateEntityQuery(typeof(ExtendChainData));
    Assert.AreEqual(3, query.CalculateEntityCount());
    
    foreach (var entity in query.ToEntityArray(Allocator.Temp))
    {
        var chain = EntityManager.GetComponentData<ExtendChainData>(entity);
        Assert.AreEqual(rootEntity, chain.RootEntity);
        Assert.AreEqual(12345, chain.ChainID);
    }
}
```

---

## ğŸ“Š æ€§èƒ½åˆ†æ

### æ—¶é—´å¤æ‚åº¦

| æ“ä½œ | å¤æ‚åº¦ | è¯´æ˜ |
|------|--------|------|
| ç¢°æ’æ£€æµ‹ | O(L) | L = é¢„è§ˆé•¿åº¦ |
| Cube ç”Ÿæˆ | O(N) | N = æ‹‰ä¼¸é•¿åº¦ |
| ç©ºé—´å“ˆå¸Œæ³¨å†Œ | O(1) | å•ä¸ª Cube |
| ç©ºé—´å“ˆå¸ŒæŸ¥è¯¢ | O(1) | å•ä¸ªåæ ‡ |
| Collider åŒæ­¥ | O(C) | C = Collider æ•°é‡ |

### å†…å­˜å ç”¨

| ç»„ä»¶ | å¤§å° | æ•°é‡ (å‡è®¾) | æ€»è®¡ |
|------|------|------------|------|
| CubeTypeTag | 1 byte | 1000 | 1 KB |
| ExtendChainData | 24 bytes | 100 | 2.4 KB |
| CubeGridPosition | 16 bytes | 1000 | 16 KB |
| OccupiedCubeMap | ~24 KB | 1 | 24 KB |
| **æ€»è®¡** | - | - | **~43 KB** |

### æ€§èƒ½å»ºè®®

1. **æ‹‰ä¼¸é•¿åº¦**: 5-10 æ ¼ï¼ˆæ¨èï¼‰
2. **åŒæ—¶æ‹‰ä¼¸é“¾æ•°**: < 5 æ¡
3. **æ€» Cube æ•°**: < 10,000
4. **ç©ºé—´å“ˆå¸Œå®¹é‡**: åŠ¨æ€æ‰©å±•ï¼ˆåˆå§‹ 1000ï¼‰

---

## ğŸ”§ æ‰©å±•ç‚¹

### 1. è‡ªå®šä¹‰é¢„è§ˆæ¸²æŸ“

æ›¿æ¢ `Debug.DrawLine` ä¸º Entity é¢„è§ˆï¼š

```csharp
// ExtendPreviewSystem.cs
private void CreatePreviewEntities()
{
    for (int i = 1; i <= previewLength; i++)
    {
        var previewEntity = ecb.Instantiate(previewPrefab);
        ecb.AddComponent(previewEntity, new PreviewTag());
        ecb.AddComponent(previewEntity, new URPMaterialPropertyBaseColor
        {
            Value = isValid ? greenTransparent : redTransparent
        });
    }
}
```

### 2. æ‹‰ä¼¸åŠ¨ç”»

åœ¨ `ExtendExecutionSystem` ä¸­æ·»åŠ  Scale åŠ¨ç”»ï¼š

```csharp
ecb.AddComponent(newCube, new ScaleAnimation
{
    StartScale = 0f,
    EndScale = 1f,
    Duration = 0.2f,
    ElapsedTime = 0f
});
```

ç„¶ååˆ›å»º `ScaleAnimationSystem`:
```csharp
public partial struct ScaleAnimationSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        foreach (var (anim, transform) in SystemAPI.Query<RefRW<ScaleAnimation>, RefRW<LocalTransform>>())
        {
            anim.ValueRW.ElapsedTime += SystemAPI.Time.DeltaTime;
            float t = math.saturate(anim.ValueRO.ElapsedTime / anim.ValueRO.Duration);
            transform.ValueRW.Scale = math.lerp(anim.ValueRO.StartScale, anim.ValueRO.EndScale, t);
        }
    }
}
```

### 3. æ”¶å›åŠŸèƒ½

åˆ›å»º `ExtendRetractSystem`:

```csharp
public partial struct ExtendRetractSystem : ISystem
{
    public void OnUpdate(ref SystemState state)
    {
        // ç›‘å¬ R é”®
        if (!Input.GetKeyDown(KeyCode.R)) return;
        
        var ecb = new EntityCommandBuffer(Allocator.Temp);
        
        // æŸ¥æ‰¾æœ€è¿‘çš„é“¾ï¼ˆæœ€å¤§ ChainIDï¼‰
        int latestChainID = 0;
        Entities.ForEach((in ExtendChainData chain) =>
        {
            if (chain.ChainID > latestChainID)
                latestChainID = chain.ChainID;
        }).Run();
        
        // åˆ é™¤è¯¥é“¾çš„æ‰€æœ‰ Cube
        Entities.ForEach((Entity entity, in ExtendChainData chain) =>
        {
            if (chain.ChainID == latestChainID)
            {
                ecb.DestroyEntity(entity);
            }
        }).Run();
        
        ecb.Playback(state.EntityManager);
    }
}
```

---

## ğŸ› è°ƒè¯•æŠ€å·§

### 1. Entity Debugger

Window â†’ Entities â†’ Hierarchy

æŸ¥çœ‹ï¼š
- ExtendPreview ç»„ä»¶å€¼
- ExtendChainData é“¾ç»“æ„
- CubeGridPosition åæ ‡

### 2. ç©ºé—´å“ˆå¸Œå¯è§†åŒ–

åœ¨ `OccupiedCubeMapSystem` ä¸­ï¼š
```csharp
void OnDrawGizmos()
{
    if (!SystemAPI.TryGetSingleton<OccupiedCubeMap>(out var map))
        return;
    
    foreach (var (pos, entity) in map.Map)
    {
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireCube((Vector3)(float3)pos, Vector3.one * 0.9f);
    }
}
```

### 3. Console æ—¥å¿—çº§åˆ«

ExtendInputManager:
- `<cyan>`: é¢„è§ˆå¼€å§‹
- `<green>`: ç¡®è®¤æ‹‰ä¼¸

ExtendExecutionSystem:
- `<green>`: æˆåŠŸ
- `<yellow>`: è­¦å‘Šï¼ˆç¢°æ’ï¼‰
- `<red>`: é”™è¯¯

---

## ğŸ“š å‚è€ƒèµ„æ–™

### Unity DOTS
- [Entities 1.0 Documentation](https://docs.unity3d.com/Packages/com.unity.entities@latest)
- [ECS Best Practices](https://docs.unity3d.com/Packages/com.unity.entities@latest/index.html?subfolder=/manual/ecs_best_practices.html)

### ç›¸å…³ç³»ç»Ÿ
- [é€‰æ‹©ç³»ç»Ÿ](./Cubeé€‰æ‹©ç³»ç»Ÿä½¿ç”¨æŒ‡å—.md)
- [å…³å¡ç®¡ç†](./å…³å¡ç®¡ç†ç³»ç»Ÿä½¿ç”¨æŒ‡å—.md)
- [Grid Brush](../Editor/GridBrush/README.md)

---

## ğŸ“ ç‰ˆæœ¬å†å²

### v1.0.0 (MVP) - 2025-10-24
- âœ… åŸºç¡€æ‹‰ä¼¸åŠŸèƒ½
- âœ… ç©ºé—´å“ˆå¸Œè¡¨ç¢°æ’æ£€æµ‹
- âœ… é”®ç›˜è¾“å…¥æ§åˆ¶
- âœ… Debug.DrawLine é¢„è§ˆ
- âœ… åŠ¨æ€ GameObject Collider

### æœªæ¥è®¡åˆ’
- v1.1.0: æ‹‰ä¼¸åŠ¨ç”»
- v1.2.0: æ”¶å›åŠŸèƒ½
- v1.3.0: é¼ æ ‡æ‹–æ‹½
- v2.0.0: ç¨³å®šæ€§ç³»ç»Ÿ

---

**æ–‡æ¡£ç»´æŠ¤**: AI Assistant & Development Team
**æœ€åæ›´æ–°**: 2025-10-24

